# 介绍装饰器decorator的用法

## 先来回忆下*args和**kwargs的用法

- 当定义一个函数，不知道要传入多少参数的时候，使用*args

输入：

```
def test(*name):
    print(type(name))
    print(name)

test(1,2,'a')
```

输出：

```
<class 'tuple'>
(1, 2, 'a')
```

- 如果想向函数中传入一些属性，可以使用**kwargs

输入：

```
def tes(**name):
    print(type(name))
    print(name)
    
tes(fruit = 'apple',veg = 'cabbage')
```

输出：

```
<class 'dict'>
{'fruit': 'apple', 'veg': 'cabbage'}
```

- 当两者混合使用的时候，**会按顺序获得值**

**注意：args必须在kwargs的前面**

输入：

```
def t(a, b, *args, **kwargs):
    print(f'a:{a}')
    print(f'b:{b}')
    print(f'args{args}')
    print(f'kwargs{kwargs}')

t(1, 'xiao', 3, 4, 5, c = 2, d = 3)
```

输出：

```
a:1
b:xiao
args(3, 4, 5)
kwargs{'c': 2, 'd': 3}
```

## 装饰器的作用

 **装饰器就是能在不改变函数的接口的情况下，给函数添加新的功能**

我们先来理解下python中的函数

```
import time

def cac():
    time1 = time.time()
    time.sleep(1)
    time2 = time.time()
    print(time2 - time1)

a = cac

a()

del cac # 删除了之前定义的函数

a()
```

**可以发现：python中定义一个函数的时候，重要的不是这个函数名，而是这个括号。括号表示函数的入口，cac只是一个变量，指向这个函数的内存，变量加括号表示调用函数里面的内容**

假如，我们要给每个函数都添加一个计算时间的功能，也就是一旦调用这个函数，那么就会显示出执行的时间。

```
import time

def cac(func):
    time1 = time.time()
    func()
    time2 = time.time()
    print(time2 - time1)

def a():
    time.sleep(1)

cac(a)
```

上面传入的函数a，用cac计算函数a的执行时间。但我希望调用a的时候，能够打印出执行的时间。

**现在我们知道了，函数名只是指向这个函数，然后就可以使用python中的闭包来不改变函数接口**

我们来看看闭包

```
import time

def cac(func):
    def inner():
        time1 = time.time()
        func()
        time2 = time.time()
        print(time2 - time1)
    return inner

def a():
    time.sleep(1)

a = cac(a)
a()
```

​	`a = cac(a)`来看看这段代码执行

1. 传入函数a，func和a指向同一个对象，然后调用cac。最后返回inner对象
2. a和inner对象，指向同一个函数
3. 调用a函数其实就是调用inner函数
4. inner函数里面有两个功能，原先函数a的sleep功能和计算运行时间

从而实现闭包

**从内存角度考虑闭包，func不是形参吗？函数调用完不会自动释放吗？不是只能在函数内部调用？**

上面代码中，有三个函数，函数a和函数cac以及inner函数

内存是这样分配的。

- 调用函数a时，内存会分一部分单独给a

- 调用函数cac时，也会单独分一部分给cac

- 调用inner函数时，会在cac的内存中，单独分一部分给inner

`a = cac(a)`执行的时候，a函数就指向cac的内存了，func指向原来a，也就是sleep功能哪个函数内存。

func本来在cac中，也就是说。我再调用函数a时。相当于调用cac.inner。所以，我们一直在调用cac函数。func形参并没有释放。



**因为python支持语法糖功能，所以可以使用@**

```
import time

def cac(func):
    def inner():
        time1 = time.time()
        func()
        time2 = time.time()
        print(time2 - time1)
    return inner

@cac # 相当于a = cac(a)
def a():
    time.sleep(1)

a()
```

**那我要传入参数怎么办？**

我们知道，调用函数a，其实就是在调用cac.inner函数。

```
import time

def cac(func):
    def inner(*args, **kwargs):
        time1 = time.time()
        func(*args, **kwargs)
        time2 = time.time()
        print(time2 - time1)
    return inner

@cac
def a(key, value):
    print(key)
    print(value)

a(1, 2)
```

- `a(1, 2)`调用的时候，相当于调用`cac.inner(key, value)`
- 然后执行`func(*args, **kwargs)`

**问题：**

```
import time

def cac(func):
    def inner(*args, **kwargs):
        time1 = time.time()
        print(
            f'args:{args}'
            # f'*args:{*args}'
            , end='\n'
            f'kwargs:{kwargs}'
            # f'**kwargs:{**kwargs}'
        )
        print()
        func(*args, **kwargs)
        time2 = time.time()
        print(time2 - time1)
    return inner

@cac
def a(key, value, c=1, b=2):
    pass


a(1, 2)
```

**注意看这个输出结果，为什么是空字典呢？**

```
args:(1, 2)
kwargs:{}
2.7179718017578125e-05
```

